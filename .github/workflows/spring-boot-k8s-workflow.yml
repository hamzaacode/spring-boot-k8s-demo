name: Spring Boot K8s Workflow

on:
  push:
    branches: [ master ]
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'Dockerfile'
      - 'k8s.yaml'
      - '.github/workflows/spring-boot-k8s-workflow.yml'
  workflow_dispatch:

env:
  SERVICE_NAME: spring-boot-k8s-demo
  K8S_FILE: k8s.yaml

concurrency:
  group: spring-boot-deploy
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute vars
        id: vars
        shell: bash
        run: |
          echo "SHORT_SHA=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"
          echo "IMAGE=${{ env.SERVICE_NAME }}:${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"
          echo "IMAGE_LATEST=${{ env.SERVICE_NAME }}:latest" >> "$GITHUB_OUTPUT"

      - name: Set up Temurin JDK 17 (with Maven cache)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: maven

      - name: Build JAR
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./mvnw || true
          ./mvnw -B -T 1C -DskipTests -Dmaven.javadoc.skip=true -Dmaven.source.skip=true clean package
          ls -lh target/*.jar

      - name: Ensure Minikube (Docker driver) is running
        shell: bash
        run: |
          set -euo pipefail
          docker info >/dev/null
          minikube status >/dev/null 2>&1 || minikube start --driver=docker
          kubectl config use-context minikube
          eval "$(minikube docker-env)"
          docker info >/dev/null

      - name: Build container image (short-SHA + latest)
        env:
          DOCKER_BUILDKIT: "1"
        shell: bash
        run: |
          set -euo pipefail
          docker build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t "${{ steps.vars.outputs.IMAGE }}" \
            -t "${{ steps.vars.outputs.IMAGE_LATEST }}" \
            .
          docker images | grep "${{ env.SERVICE_NAME }}" || true

      - name: Apply manifests
        shell: bash
        run: |
          set -euo pipefail
          kubectl apply -f "${{ env.K8S_FILE }}"

      - name: Rollout new image
        shell: bash
        run: |
          set -euo pipefail
          kubectl set image deployment/${{ env.SERVICE_NAME }} \
            ${{ env.SERVICE_NAME }}=${{ steps.vars.outputs.IMAGE }} --record
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} --timeout=180s
          kubectl get deploy/${{ env.SERVICE_NAME }} -o wide
          kubectl get pods -l app=${{ env.SERVICE_NAME }} -o wide

      - name: Determine service URL
        id: url
        shell: bash
        run: |
          set -euo pipefail
          URL="$(minikube service ${{ env.SERVICE_NAME }} --url)"
          echo "url=$URL" >> "$GITHUB_OUTPUT"
          echo "Service URL: $URL"

      - name: Verify
        shell: bash
        run: |
          set -euo pipefail
          URL="${{ steps.url.outputs.url }}"
          echo "Checking health at: $URL/actuator/health"
          for i in {1..10}; do
            if curl -fsS "$URL/actuator/health" | grep -q '"status":"UP"'; then
              echo "Health OK"
              break
            fi
            sleep 6
          done
          echo "Ping /hello"
          curl -fS "$URL/hello" && echo

      - name: Diagnostics on failure
        if: failure()
        shell: bash
        run: |
          set +e
          kubectl get events --sort-by=.lastTimestamp | tail -n 200 || true
          kubectl describe deploy ${{ env.SERVICE_NAME }} || true
          kubectl describe pods -l app=${{ env.SERVICE_NAME }} || true
          POD="$(kubectl get pods -l app=${{ env.SERVICE_NAME }} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)"
          [ -n "$POD" ] && kubectl logs "$POD" --all-containers=true || true