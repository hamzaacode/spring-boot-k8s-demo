name: Spring Boot K8s Workflow

on:
  push:
    branches: [ master ]
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'Dockerfile'
      - 'k8s.yaml'
      - '.github/workflows/spring-boot-k8s-workflow.yml'
  workflow_dispatch:

env:
  IMAGE_TAG: spring-boot-k8s-demo:latest
  DEPLOY_DIR: .

concurrency:
  group: spring-boot-deploy
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: self-hosted
    steps:
    - name: Clean diagnostic logs
      run: |
        echo "Cleaning up old diagnostic logs..."
        rm -rf /Users/md.amirhamza/spring-k8s-runner/_diag/* || true

    - name: Prepare diagnostic dir
      run: |
       echo "Preparing diagnostics dir..."
       export DIAG_DIR="$RUNNER_TEMP/diag-${GITHUB_RUN_ID}"
       mkdir -p "$DIAG_DIR"
       echo "DIAG_DIR=$DIAG_DIR" >> $GITHUB_ENV

    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Initial Diagnostics
      run: |
        echo "Runner user: $(whoami)"
        echo "Java version:"
        java -version || echo "Java not found"
        echo "Maven version:"
        mvn -v || echo "Maven not found"
        echo "Docker version:"
        docker --version || echo "Docker not found"
        echo "Minikube version:"
        minikube version || echo "Minikube not found"
        echo "Kubectl version:"
        kubectl version --client || echo "Kubectl not found"
        
    - name: System Check
      run: |
        # Check if Docker daemon is running
        docker info || echo "Docker daemon not running"
        
        # Check minikube status
        minikube status || echo "Minikube not running"
        
        # Check kubectl context
        kubectl config current-context || echo "No kubectl context set"

    - name: Cache Maven packages
      id: maven-cache
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
      continue-on-error: true  # Don't fail the build if caching fails

    - name: Set Java 17 as default
      run: |
        echo "Setting up Java 17..."
        export JAVA_HOME="/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home"
        export PATH="$JAVA_HOME/bin:$PATH"
        java -version

    - name: Build fat JAR
      run: |
        set -euxo pipefail
        echo "Building JAR file..."
        chmod +x ./mvnw
        ./mvnw clean package \
          -DskipTests \
          -T 1C \
          --batch-mode \
          --no-transfer-progress \
          -Dmaven.javadoc.skip=true \
          -Dmaven.source.skip=true
        
        echo "Verifying JAR file..."
        ls -l target/*.jar || { echo "JAR file not created"; exit 1; }

    - name: Setup Minikube with retries
      run: |
        set -euxo pipefail
        
        MAX_RETRIES=3
        RETRY_COUNT=0
        
        until minikube status || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
          echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES to start Minikube"
          minikube delete || true
          minikube start --driver=docker --kubernetes-version=stable
          RETRY_COUNT=$((RETRY_COUNT + 1))
          sleep 10
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ] && ! minikube status; then
          echo "Failed to start Minikube after $MAX_RETRIES attempts"
          exit 1
        fi
        
        # Set docker env
        eval $(minikube docker-env)
        echo "Connected to Minikube's Docker daemon"
        
        # Verify connection
        docker info
        minikube status

    - name: Build Docker image with BuildKit
      env:
        DOCKER_BUILDKIT: 1
      run: |
        set -euxo pipefail
        docker build \
          --cache-from ${{ env.IMAGE_TAG }} \
          --build-arg BUILDKIT_INLINE_CACHE=1 \
          -t ${{ env.IMAGE_TAG }} \
          .
        echo "Docker image built successfully"
        docker images | grep spring-boot-k8s-demo

    - name: Deploy to Minikube
      run: |
        set -euxo pipefail
        
        echo "Cleaning up any existing deployments..."
        kubectl delete deployment spring-boot-k8s-demo --ignore-not-found
        kubectl delete service spring-boot-k8s-demo --ignore-not-found
        
        echo "Applying Kubernetes configurations..."
        kubectl apply -f k8s.yaml
        
        echo "Waiting for deployment to be ready..."
        if ! kubectl rollout status deployment/spring-boot-k8s-demo --timeout=180s; then
          echo "Deployment failed. Checking pod status and logs..."
          kubectl describe pods -l app=spring-boot-k8s-demo
          kubectl logs -l app=spring-boot-k8s-demo --all-containers=true
          exit 1
        fi
        
        echo "Checking deployment status..."
        kubectl get deployment spring-boot-k8s-demo -o wide
        kubectl get pods -l app=spring-boot-k8s-demo -o wide
        
        echo "Setting up port forwarding..."
        # Kill any existing port-forward
        pkill -f "kubectl port-forward" || true
        
        # Start port forwarding in the background
        kubectl port-forward service/spring-boot-k8s-demo 8080:8080 &
        
        # Save the port-forward PID
        echo $! > port-forward.pid
        
        # Wait for port-forward to be ready
        sleep 5

    - name: Verify Deployment
      run: |
        set -euxo pipefail
        
        echo "Waiting for service to be fully ready..."
        sleep 15
        
        # Test the service through port-forward
        echo "Testing application endpoints..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        until curl -s --fail "http://localhost:8080/hello" || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
          echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES to reach application"
          sleep 10
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "Application health check failed. Gathering diagnostics..."
          kubectl get events --sort-by='.lastTimestamp'
          kubectl describe pods -l app=spring-boot-k8s-demo
          POD=$(kubectl get pods -l app=spring-boot-k8s-demo -o jsonpath="{.items[0].metadata.name}")
          echo "Application logs:"
          kubectl logs $POD --all-containers=true
          exit 1
        fi
        
        echo "Deployment verification successful!"
        
        # Cleanup port-forward
        if [ -f port-forward.pid ]; then
          kill $(cat port-forward.pid) || true
          rm port-forward.pid
        fi

    - name: Cleanup
      if: always()  # Run this step even if previous steps fail
      run: |
        set +e  # Don't exit on error during cleanup
        
        echo "Cleaning up resources..."
        
        # Kill any remaining port-forward processes
        pkill -f "kubectl port-forward" || true
        
        # Clean up any port-forward PID files
        rm -f port-forward.pid
        
        # Clean up Minikube resources
        kubectl delete deployment spring-boot-k8s-demo --ignore-not-found
        kubectl delete service spring-boot-k8s-demo --ignore-not-found
        
        # Clear Docker build cache if needed
        docker system prune -f
        
        # Remove any leftover files
        rm -rf target/
        
        # Clean up diagnostic logs
        rm -rf /Users/md.amirhamza/spring-k8s-runner/_diag/* || true
        
        echo "Cleanup completed"
